<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <style>
        html, body {
            height: 100%;
        }
        body {
            margin: 0;
            display: grid;
            grid-template-areas:    "edit preview"
                                    "menu preview";
            grid-template-columns: 50vw 50vw;
            grid-template-rows: 1fr min-content;
        }

        #predictive {
            position:absolute;
            background-color: red;
            z-index: 10;
            padding: 0;
            margin: 0;
            list-style: none;
        }

        #predictive li.selected {
            background-color: yellow;
        }

        #predictive li.selected button::after {
            content: "(Tab)";
            font-style: italic;
            padding-left: 1em;
        }

        ul#predictive > li:first-child 

        #edit {
            grid-area: edit;
            position: relative;
        }

        #menu {
            grid-area: menu;
        }

        #truth {
            grid-area: truth;
            background-color: grey;
            color: white;
            display: none;
        }

        #preview {
            grid-area: preview;
            height: 100%;
            width: 100%;
            border: 0;
        }

        #edit,
        #truth {
            font-family: monospace;
            font-size: 1.25em;
            font-weight: 400;
        }

        .hidden{
            display: none;;
        }


        
        
        </style>


        <style>
            @counter-style lines {
                system: numeric;
                symbols: "0" "1" "2" "3" "4" "5" "6" "7" "8" "9";
                suffix: ": ";
            }

            .editor-view {
                list-style: lines;
                margin: 0;
                background-color: rgb(37, 37, 37);
                
            }

            .editor-line:hover {
                background-color: rgb(65, 65, 65);
            }

            .editor-line:focus {
                background-color: red;
            }

            .editor-line[data-mimetype="css"]::marker {
                color: green;
            }

            

            .editor-line[data-mimetype="html"]::marker {
                color: blue;
            }

            .editor-line[data-mimetype="js"]::marker {
                color: yellow;
            }

            .highlight {
                background-color: green;
            }

            .highlight-error {
                background-color: red;
            }

            span.validator-syntax-error {
                text-decoration: underline dashed red;
                text-decoration-thickness: from-font;
                }

            span.validator-invalid {
                text-decoration: underline dashed red;
                text-decoration-thickness: from-font;
            }

            span.validator-attr-not-found {
                text-decoration: underline dashed red;
                text-decoration-thickness: from-font;
            }

            span.validator-tag-not-found {
                text-decoration: underline dashed red;
                text-decoration-thickness: from-font;
            }

            [data-validator-syntax-error] {
                position: relative;
            }

            [data-validator-syntax-error]:hover:after {
                content: attr(data-validator-syntax-error);
                position: absolute;
                background: rgba(255, 255, 255, 0.9);
                padding: 0.25em 0.5em;
                font-size: 0.75em;
                top: 1.25em;
                color: red;
                font-weight: 900;
                left: 0;
                white-space: pre;
            }

            .orphan-html-tag {
                background-color: purple;
            }

            .highlight-value,
            .highlight-value-start,
            .highlight-value-end {
                background-color: rgba(255, 255, 255, 0.2);
                /*border-top: 1px solid red;
                border-bottom: 1px solid red;*/
            }

            .highlight-value-start {
                /*border-left: 1px solid red;*/
            }

            .highlight-value-end {
                /*border-right: 1px solid red;*/
            }

            

            
        </style>

        
<style>
    .css-multiline-comment,
    .css-comment {
        color: green;
    }
    .css-spacer {}
    .css-property {
        color: aqua;
    }
    .css-value {
        color: coral;
    }
    .css-curly-open,
    .css-curly-close {
        color: yellow;
    }
    .css-colon {}
    .css-semi-colon {}
    .css-selector {
        color: orange;
    }
</style>

<style>
    .js-multiline-comment,
    .js-comment {
        color: green;
    }
    .js-backtick {
        color: coral;
    }
    .js-literal-value {
        color: coral;
    }
    .js-literal-dollar,
    .js-literal-curly-open,
    .js-literal-curly-close {
        color:rgb(7, 156, 255)
    }
    
    .js-literal-variable {
        color: aqua;
    }

    .js-string {
        color: coral;

    }
    .js-property {
        color: aqua;

    }

    .js-private-property {
        color: darkcyan;

    }
    .js-method-name {
        color:yellow
    }
    .js-symbol {
        color: white;
    }
    .js-quote {
        color: coral;
    }
    .js-keyword {
        color:rgb(7, 156, 255)
    }
    .js-keyword-const {}
    .js-keyword-let {}
    .js-keyword-var {}
    .js-keyword-static {}
    .js-keyword-class {}
    .js-path {
        color: aqua;
    }
    .js-private-variable {}
    .js-variable {
        color: aqua;
    }

    .js-bracket-open,
    .js-bracket-close,
    .js-square-bracket-open,
    .js-square-bracket-close,
    .js-curly-brace-open,
    .js-curly-brace-close {
        color: yellow;
    }
</style>

<style>
    .json-prop {
        color: aqua;
    }
</style>

<style>
    .editor-view[data-show-whitespace="true"] .css-spacer,
    .editor-view[data-show-whitespace="true"] .html-spacer, 
    .editor-view[data-show-whitespace="true"] .editor-indent,
    .editor-view[data-show-whitespace="true"] .editor-spaces {
        background: url(/media/icons/circle.svg) repeat-x;
        background-size: 0.55em;
        background-position-y: center;
    }

    .editor-view[data-show-whitespace="true"] .editor-line::after {
        background: url(/media/icons/linefeed.svg) repeat-x;
        background-size: 0.55em;
        background-position-y: center;
        content: " "
    }


    .editor-line[data-mimetype="html"] {
        color: white;
    }

    .editor-line[data-mimetype="css"] {
        color: white;
    }

    .editor-line[data-mimetype="js"] {
        color: white;
    }
    
    .html-nodename {
        color:rgb(7, 156, 255)
    }
    
    .html-equal-sign {
        color: white
    }
    .html-attr-quote-open,
    .html-attr-quote-close {
        color: lightcoral
    }
    .html-attr-name {
        color: aqua;
    }
    .html-attr-value {
        color: coral;
    }
    .html-bracket-left,
    .html-bracket-right,
    .html-back-slash {
        color: grey
    }

    .html-lineIndent {
        background: url(/media/icons/space.png) repeat-x;
        background-size: 0.55em;
        background-position-y: center;
    }
    
</style>

</head>
<body>
    
    <ul id="predictive" data-status="closed"></ul>
    <ul data-show-whitespace="false" class="editor-view" id="edit" contenteditable="plaintext-only" spellcheck="false"></ul>
    <textarea id="truth">
<style>
    .title {
        background-color: blue;
    }
</style>
<h1 class="title">Hello</h1>
<p id="name">Name</p>
<script>
    const username = "Lee";
    const name = document.getElementById("name");
    name.textContent = username;
    console.log(`name:  ${name}`)
</script>
    </textarea>
    <menu id="menu">
        <li><button type="button" id="validate">Validate</button></li>
    </menu>
    <iframe id="preview"></iframe>

    <script>

        const getTokenAt = (line, caretPosition) => {
            const treeWalk = document.createTreeWalker(line, NodeFilter.SHOW_TEXT);
            let counter = 0;
            let targetNode = null;

            while(treeWalk.nextNode()) {
                if(counter + treeWalk.currentNode.textContent.length >= caretPosition){
                    targetNode = treeWalk.currentNode;
                    break;
                }

                counter += treeWalk.currentNode.textContent.length
            }
            return (targetNode)
                ? getToken(targetNode)
                : null
        }

        const getToken = (node) => {
            const parentNode = node.parentNode;
            const target = (parentNode.classList.contains("token"))
                ? parentNode
                : null
             

            return target
        }

        const getInfo = () => {
            const anchorNode = selection.anchorNode;

            const {line, mimetype, character, token} = getCaretPosition(anchorNode);

            return {
                line,
                mimetype,
                character,
                token,
            }
        }

        

        const createFragmentFromString = (htmlString) => {
            const range = document.createRange();
            const docFragment = range.createContextualFragment(htmlString);
            
            return docFragment;
        }
        
        const predictive = document.getElementById("predictive")
        const edit = document.getElementById("edit")
        const truth = document.getElementById("truth")
        const preview = document.getElementById("preview")
        const validate = document.getElementById("validate")

        
        const parseDOM = (rootNode) => {
            const treeWalk = document.createTreeWalker(rootNode, NodeFilter.SHOW_ELEMENT,
                (node) => {
                    return node.classList.contains("html-opening-tag") ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
                }
            );

            const DOM = {}

            while(treeWalk.nextNode()) {
                const currentNode = treeWalk.currentNode;
                const tagName = currentNode.textContent;
                
                if(!DOM[tagName]){
                    DOM[tagName] = []
                }

                

                DOM[tagName].push({
                    tag: currentNode,
                    attributes: []
                })

                let walkTag = currentNode.nextSibling;

                while (walkTag){


                    if(!walkTag){
                        walkTag = parentNextSibling(walkTag)
                    
                    } else if(!walkTag.classList) {
                        walkTag = walkTag.nextSibling
                    
                    } else {

                        if(walkTag.classList.contains("html-bracket-right")){
                            break;

                        } else if(walkTag.classList.contains("html-bracket-left")){
                            break;

                        } else {
                            if(walkTag.classList.contains("html-attr-name")){
                                DOM[tagName][DOM[tagName].length - 1].attributes.push({
                                    name: walkTag
                                })

                            } else if(walkTag.classList.contains("html-attr-value")){
                                DOM[tagName][DOM[tagName].length - 1].attributes[DOM[tagName][DOM[tagName].length - 1].attributes.length - 1].value = walkTag
                                
                            }

                            walkTag = walkTag.nextSibling;
                        }

                    }


                }
                
            }

            return DOM
        }
        let DOMElementCounter = 0;

        const validateDoc = (node = edit) => {
            console.log("validateDoc ::: node:", node)
            const DOM = parseDOM(node);
            Object.entries(DOM).forEach(([tagName, elementList]) => {
                const ElementSpecs = HTMLElements.find((_el => _el.name === tagName))

                    elementList.forEach((element) => {
                        const closingTag = findClosingToken2(element.tag, "html-opening-tag", "html-closing-tag", element.tag.textContent)
                        if(closingTag){
                            let tagPairId = DOMElementCounter++;
                            element.tag.dataset.tagPairId = tagPairId
                            element.tag.dataset.tagPairPosition = "start"
                            closingTag.dataset.tagPairId = tagPairId
                            closingTag.dataset.tagPairPosition = "end"
                            element.tag.classList.remove("orphan-html-tag")
                        } else {
                            element.tag.classList.add("orphan-html-tag")
                        }
                        if(ElementSpecs){
                            element.tag.classList.remove("validator-tag-not-found")
                            element.tag.removeAttribute("data-validator-tag-not-found")
                            element.tag.removeAttribute("data-validator-syntax-error")

                        } else {
                            if(element.tag.textContent.split("-").length > 1){
                                console.log("CUSTOM TAG:", element.tag)
                            } else {
                                // Tag is invalid ... What to do ?
                                element.tag.classList.add("validator-tag-not-found")
                                element.tag.dataset.validatorSyntaxError = `<${tagName}> is not a valid HTML tag`;
                            }
                        }


                        if(!element.closingTag){
                            //console.log("No closing tag for: ", element)
                        }
                        
                        element.attributes.forEach((attribute) => {
                            const attrName = attribute.name.textContent;
                            const attrValue = attribute.value.textContent;
                            let standard = null;

                            if(ElementSpecs){
                                const attrDefinition = HTMLAttributes.find(attr => attr.name === attrName)

                                if(attrDefinition){
                                    if(attrDefinition.global || ElementSpecs.attributes.standard.find(_attrName => _attrName === attrName)){
                                        standard = "html-attr-standard"
                                    } else if(ElementSpecs.attributes.nonStandard.find(_attrName => _attrName === attrName)){
                                        standard = "html-attr-nonstandard"
                                    } else if(ElementSpecs.attributes.deprecated.find(_attrName => _attrName === attrName)){
                                        standard = "html-attr-deprecated"
                                    } else if(ElementSpecs.attributes.experimental.find(_attrName => _attrName === attrName)){
                                        standard = "html-attr-experimental"
                                    } 

                                    if(standard){
                                        attribute.name.classList.add(standard)
                                        const attributeRE = attrDefinition.validation.default.re;
                                        const attributeHelper = attrDefinition.validation.default.helper;
                                        const valid = attrValue.match(attributeRE);

                                        if(valid){
                                            attribute.value.classList.add("validator-valid")

                                        } else {
                                            attribute.value.classList.add("validator-syntax-error")
                                            attribute.value.dataset.validatorSyntaxError = `[${attrName}] ${attributeHelper}]`;
                                        }

                                    } else {
                                        attribute.name.classList.add("validator-invalid")
                                        attribute.name.dataset.validatorSyntaxError = `<${tagName}> does not accept [${attrName}] attribute`;
                                    }
                                } else {
                                    // attribute not valid for this tag
                                    attribute.name.classList.add("validator-attr-not-found")
                                    attribute.name.dataset.validatorSyntaxError = `[${attrName}] attribute doest exist`;
                                }
                            } 

                            

                            


                        })
                    })

                
                
                
            })

        }

        

       
        validate.addEventListener("click", validateDoc)

        edit.addEventListener("typedown", (event) => {
            if(event.detail.eventListeners){
                // Requested eventListener
                const listeners = event.detail.eventListeners.filter(eventListener => eventListener.type === "typedown")
                
                if(listeners.length === 0){
                    return false;
                }

                listeners.forEach(listener => {
                    const callback = eventListeners[listener.id];

                    if(callback){
                        callback(event.detail, {...listener.params})
                    }
                })
            }
        })

        edit.addEventListener("typeup", (event) => {
            if(event.detail.eventListeners){
                // Requested eventListener
                const listeners = event.detail.eventListeners.filter(eventListener => eventListener.type === "typeup")
                
                if(listeners.length === 0){
                    return false;
                }

                listeners.forEach(listener => {
                    const callback = eventListeners[listener.id];

                    if(callback){
                        callback(event.detail, {...listener.params})
                    }
                })


                
            }
        })

        
        edit.addEventListener("navigateleave", (event) => {
            if(event.detail.eventListeners){
                // Requested eventListener
                const listeners = event.detail.eventListeners.filter(eventListener => eventListener.type === "navigateleave")
                
                if(listeners.length === 0){
                    return false;
                }

                listeners.forEach(listener => {
                    const callback = eventListeners[listener.id];

                    if(callback){
                        callback(event.detail, {...listener.params})
                    }
                })
            }
            
        })

        edit.addEventListener("navigateenter", (event) => {
            if(event.detail.eventListeners){
                // Requested eventListener
                const listeners = event.detail.eventListeners.filter(eventListener => eventListener.type === "navigateenter")
                
                if(listeners.length === 0){
                    return false;
                }

                listeners.forEach(listener => {
                    const callback = eventListeners[listener.id];

                    if(callback){
                        callback(event.detail, {...listener.params})
                    }
                })
            }
        })

        const killPredictive = (line) => {
            if(predictive.dataset.status === "open"){
                predictive.replaceChildren()
                predictive.dataset.status = "closed";
                if(line){
                    //setCaretPosition({line: line.line, caretPosition: line.caretPosition});
                }
            }
        }

        let lineOnClosePredictive = null;

        const predictiveTagName = ({token, parentLine, callback} = {}) => {
            lineOnClosePredictive = parentLine;
            const nodeBox = token.getBoundingClientRect();
            const plaintext = token.textContent;
            // Still need to check parent to see if it a valid tag
            const matches = HTMLElements.filter(element => element.name.startsWith(plaintext))

            const listItems = matches.map(element => {
                const li = document.createElement("li");
                const button = document.createElement("button")
                const textNode= document.createTextNode(element.name);
                
                button.addEventListener("click", (event) => {
                    if(callback){
                        callback(textNode.textContent)
                    }
                    //console.log("Set tag to: ", textNode);
                    //token.innerHTML = textNode.textContent;
                    killPredictive();

                    /*updateEditor(token);
                    updatePreview(edit);
                    validateDoc()*/
                    
                }, {once: true})

                li.append(button)
                button.append(textNode);

                return li
            })

            predictive.style.top = `${nodeBox.bottom}px`;
            predictive.style.left = `${nodeBox.left}px`;
            predictive.replaceChildren(...listItems);
            predictive.dataset.status = "open";



        }

        const navigatePredictiveMenu = (direction) => {
            const firstButton = predictive.querySelector("li");
            const selectedButton = predictive.querySelector("li.selected");
            const nextButton = (selectedButton) ? selectedButton.nextElementSibling : firstButton;
            const lastButton = predictive.querySelector("li:last-child");
            const previousButton = (selectedButton) ? selectedButton.previousElementSibling : firstButton;

            if(selectedButton){
                selectedButton.classList.remove("selected")
            }

            if(direction === "ArrowDown"){
                if(nextButton){
                    nextButton.classList.add("selected")
                } else {
                    firstButton.classList.add("selected")
                }
            } else if(direction === "ArrowUp"){
                if(previousButton){
                    previousButton.classList.add("selected")
                } else {
                    lastButton.classList.add("selected")
                }
            }
        }

        

        // Add event listeners to edit
        edit.addEventListener("keyup", (event) => {
            const key = event.key;
            const anchorNode = selection.anchorNode;
            const caret = getCaret();
            const metaKey = event.metaKey;
            const altKey = event.altKey;
            const shiftKey = event.shiftKey;
            const ctrlKey = event.ctrlKey;
            const nonWhiteSpace = key.match(/^\S$/);
            const enterKey = (key === "Enter")
            const delKey = (key === "Backspace" || key === "Delete")

            const typeKey = ((nonWhiteSpace || enterKey || delKey)
                                && !metaKey
                                && !altKey
                                && !ctrlKey) ? true : false
            /*console.group("KEYUP", typeKey)
            console.log("nonWhiteSpace:", nonWhiteSpace)
            console.log("enterKey:", enterKey)
            console.log("delKey:", delKey)
            console.log("metaKey:", metaKey)
            console.log("altKey:", altKey)
            console.log("ctrlKey:", ctrlKey)
            console.groupEnd();*/

            if(typeKey) {
                dispatchTypeUp();
            }


            const navButtons = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"]
            const isNav = navButtons.find(navKey => navKey === key);
            if(isNav){
                dispatchNav();
            } else {
                /*if(caret.token && caret.token.classList && caret.token.classList.contains("html-nodename")){
                    predictiveTagName({...caret})
                } else {
                    killPredictive();
                }*/
            }
            

            
        })

        let previousNavCaret = null

        const dispatchTypeDown = () => {
            const detail = getCaret();
            detail.type = "typedown";

            detail.target.dispatchEvent(
                new CustomEvent("typedown", {
                    bubbles: true,
                    detail: detail,
                })
            )
        }

        const dispatchTypeUp = () => {
            const detail = getCaret();
            detail.type = "typeup";

            detail.target.dispatchEvent(
                new CustomEvent("typeup", {
                    bubbles: true,
                    detail: detail,
                })
            )
        }

        const dispatchNav = () => {
            
            const caret = getCaret();

            if(previousNavCaret && previousNavCaret.target !== caret.target){
                previousNavCaret.target.dispatchEvent(
                    new CustomEvent("navigateleave", {
                        bubbles: true,
                        detail: previousNavCaret,
                    })
                )
            }


            caret.target.dispatchEvent(
                new CustomEvent("navigateenter", {
                    bubbles: true,
                    detail: caret,
                })
            )

            previousNavCaret = caret;

        }

        edit.addEventListener("click", (event) => {
            dispatchNav();
        })

        edit.addEventListener("keydown", (event) => {
            //console.log(event)
            const metaKey = event.metaKey;
            const altKey = event.altKey;
            const shiftKey = event.shiftKey;
            const ctrlKey = event.ctrlKey;
            const key = event.key;
            const anchorNode = selection.anchorNode;
            const {line} = getLine(anchorNode)
            const caret = getCaret()
            const nonWhiteSpace = key.match(/^\S$/);
            const enterKey = (key === "Enter")
            const delKey = (key === "Backspace" || key === "Delete")

            const typeKey = ((nonWhiteSpace || enterKey || delKey)
                                && !metaKey
                                && !altKey
                                && !ctrlKey) ? true : false
            /*console.group("KEYDOWN", typeKey)
            console.log("nonWhiteSpace:", nonWhiteSpace)
            console.log("enterKey:", enterKey)
            console.log("delKey:", delKey)
            console.log("metaKey:", metaKey)
            console.log("altKey:", altKey)
            console.log("ctrlKey:", ctrlKey)
            console.groupEnd();*/

            if(typeKey) {
                dispatchTypeDown();
            }

            switch(key){
                case "Escape":
                    if(predictive.dataset.status === "open"){
                        killPredictive(); // Keep up and down for navigating through drop down
                    }
                    break;
                case "ArrowUp":
                case "ArrowDown":
                    if(predictive.dataset.status === "open"){
                        event.preventDefault();
                        navigatePredictiveMenu(key)
                        break;
                    } else {
                        //dispatchNav();
                    }
                    break;
                case "ArrowLeft":
                case "ArrowRight":
                    killPredictive(); // Keep up and down for navigating through drop down
                    //dispatchNav()
                    break;
            }

            if(key === "Tab"){
                event.preventDefault();
                if(predictive.dataset.status === "open"){
                    predictive.querySelector("li.selected button").click()
                } else {
                    if(shiftKey){
                        console.log("Tab Left")
                    } else {
                        console.log("Insert tab")
                    }
                }
                
            }


            if(ctrlKey && key.toLowerCase() === "z"){
                /*console.group("GET HISTORY")
                console.log("history:", history)
                console.log("redo:", redo)
                console.groupEnd();

                event.preventDefault();
                if(shiftKey){
                    // REDO
                    const redoState = redo.pop();
                    history.push(redoState)

                    if(redoState) {
                        stopObserving();

                        let parsed = parse(redoState, "html")
                        edit.innerHTML = parsed

                        startObserving();
                    } else {
                        console.log("NO REDO.")
                    }
                } else {
                    // UNDO
                    const previousState = history.pop()
                    redo.push(previousState);

                    if(previousState){
                        stopObserving();

                        let parsed = parse(previousState, "html")
                        edit.innerHTML = parsed

                        startObserving();

                    } else {
                        console.log("NO UNDO.")
                    }
                }*/

                
            }
        })

        const previewWindow = preview.contentWindow;


        const wrapTokenDELETE = (plaintext, classes, actions = null) => {
            const wrapper = document.createElement("span")
            wrapper.classList.add(...classes, "token")

            if(actions){
                wrapper.dataset.actions = JSON.stringify(actions); 
            }
            
            const textNode = document.createTextNode(plaintext);

            wrapper.append(textNode);

            return wrapper
        }

        const wrapToken = ({textContent, classes, eventListeners = null} = {}) => {
            const wrapper = document.createElement("span")
            wrapper.classList.add(...classes, "token")

            if(eventListeners){
                wrapper.dataset.eventListeners = JSON.stringify(eventListeners); 
            }
            
            const textNode = document.createTextNode(textContent);

            wrapper.append(textNode);

            return wrapper
        }

        

        const spacer = (length) => {
            return " ".repeat(length)
        }


        const parentNextSibling = (node) => {
            const sibling = node.parentNode.nextElementSibling;
            const firstChild = (sibling) ? sibling.firstChild : null;

            return firstChild;
        }

        const parentPreviousSibling = (node) => {
            const sibling = node.parentNode.previousElementSibling;
            const lastChild = (sibling) ? sibling.lastChild : null;

            return lastChild;
        }

        const findClosingToken = (startToken, openingTokenType, closingTokenType, closingTokenTextContent) => {
            let walkNode = startToken.nextSibling || parentNextSibling(startToken);
            let nest = 0;
            let endNode = null;

            while (walkNode) {
                const classList = walkNode.classList;

                if(classList){

                    if(classList.contains(openingTokenType)){
                        nest++;
                    } else if(classList.contains(closingTokenType)){

                        if(nest === 0){
                            endNode = walkNode;
                            break;
                        } else {
                            nest--;
                        }

                    }

                }

                walkNode = walkNode.nextSibling || parentNextSibling(walkNode);

                
            }

            if(!endNode || (closingTokenTextContent && endNode.textContent !== closingTokenTextContent)){
                return null
            }

            return endNode
        }


        const findClosingToken2 = (startToken, openingTokenType, closingTokenType, closingTokenTextContent) => {
            let walkNode = startToken.nextSibling || parentNextSibling(startToken);
            let nest = 0;
            let endNode = null;

            while (walkNode) {
                const classList = walkNode.classList;

                if(classList){

                    if(classList.contains(openingTokenType) && walkNode.textContent === closingTokenTextContent){
                        nest++;
                    } else if(classList.contains(closingTokenType) && walkNode.textContent === closingTokenTextContent){

                        if(nest === 0){
                            endNode = walkNode;
                            break;
                        } else {
                            nest--;
                        }

                    }

                }

                walkNode = walkNode.nextSibling || parentNextSibling(walkNode);

                
            }

            if(!endNode || (closingTokenTextContent && endNode.textContent !== closingTokenTextContent)){
                return null
            }

            return endNode
        }

        

        const findOpeningToken = (endToken, openingTokenType, closingTokenType, openingTokenTextContent) => {
            let walkNode = endToken.previousSibling || parentPreviousSibling(endToken);
            let nest = 0;
            let startNode = null;

            while (walkNode) {
                const classList = walkNode.classList;

                if(classList){

                    if(classList.contains(closingTokenType)){
                        nest++;
                    } else if(classList.contains(openingTokenType)){

                        if(nest === 0){
                            startNode = walkNode;
                            break;
                        } else {
                            nest--;
                        }

                    }

                }

                walkNode = walkNode.previousSibling || parentPreviousSibling(walkNode);
                
            }

            if(!startNode || (openingTokenTextContent && startNode.textContent !== openingTokenTextContent)){
                return null
            }

            return startNode
        }
        
        const HTMLAttributes = [
            {
                name: "leetest",
                global: false,
                deprecated: false,
                standard: false,
                nonStandard: true,
                experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /^\S$/g,
                        helper: "Must contain one single letter"
                    },
                    exceptions: [
                        {
                            element: "a",
                            re: /^\S$/g
                        }
                    ]
                }
            },{
                name: "accesskey",
                global: true,
                deprecated: false,
                nonStandard: false,
                standard:true,
experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /^\S$/g
                    },
                    exceptions: [
                        {
                            element: "a",
                            re: /^\S$/g
                        }
                    ]
                }
            },{
                name: "autocapitalize",
                global: true,
                deprecated: false,
                nonStandard: false,
                standard:true,
experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /[\s\S]+/g
                    },
                    exceptions: []
                }
            },{
                name: "autofocus",
                global: true,
                deprecated: false,
                nonStandard: false,
                standard:true,
experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /[\s\S]+/g
                    },
                    exceptions: []
                }
            },{
                name: "class",
                global: true,
                deprecated: false,
                nonStandard: false,
                standard:true,
experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /^[a-zA-Z_0-9 -]+$/g
                    },
                    exceptions: []
                }
            },{
                name: "contenteditable",
                global: true,
                deprecated: false,
                nonStandard: false,
                standard:true,
experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /[\s\S]+/g
                    },
                    exceptions: []
                }
            },{
                name: "data-*",
                global: true,
                deprecated: false,
                nonStandard: false,
                standard:true,
experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /[\s\S]+/g
                    },
                    exceptions: []
                }
            },{
                name: "dir",
                global: true,
                deprecated: false,
                nonStandard: false,
                standard:true,
experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /[\s\S]+/g
                    },
                    exceptions: []
                }
            },{
                name: "draggable",
                global: true,
                deprecated: false,
                nonStandard: false,
                standard:true,
experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /[\s\S]+/g
                    },
                    exceptions: []
                }
            },{
                name: "enterkeyhint",
                global: true,
                deprecated: false,
                nonStandard: false,
                standard:true,
experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /[\s\S]+/g
                    },
                    exceptions: []
                }
            },{
                name: "exportparts",
                global: true,
                deprecated: false,
                nonStandard: false,
                standard:true,
experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /[\s\S]+/g
                    },
                    exceptions: []
                }
            },{
                name: "hidden",
                global: true,
                deprecated: false,
                nonStandard: false,
                standard:true,
experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /[\s\S]+/g
                    },
                    exceptions: []
                }
            },{
                name: "id",
                global: true,
                deprecated: false,
                nonStandard: false,
                standard:true,
experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /[\s\S]+/g
                    },
                    exceptions: []
                }
            },{
                name: "inert",
                global: true,
                deprecated: false,
                nonStandard: false,
                standard:true,
experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /[\s\S]+/g
                    },
                    exceptions: []
                }
            },{
                name: "inputmode",
                global: true,
                deprecated: false,
                nonStandard: false,
                standard:true,
experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /[\s\S]+/g
                    },
                    exceptions: []
                }
            },{
                name: "is",
                global: true,
                deprecated: false,
                nonStandard: false,
                standard:true,
experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /[\s\S]+/g
                    },
                    exceptions: []
                }
            },{
                name: "itemid",
                global: true,
                deprecated: false,
                nonStandard: false,
                standard:true,
experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /[\s\S]+/g
                    },
                    exceptions: []
                }
            },{
                name: "itemprop",
                global: true,
                deprecated: false,
                nonStandard: false,
                standard:true,
experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /[\s\S]+/g
                    },
                    exceptions: []
                }
            },{
                name: "itemprop",
                global: true,
                deprecated: false,
                nonStandard: false,
                standard:true,
experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /[\s\S]+/g
                    },
                    exceptions: []
                }
            },{
                name: "itemref",
                global: true,
                deprecated: false,
                nonStandard: false,
                standard:true,
experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /[\s\S]+/g
                    },
                    exceptions: []
                }
            },{
                name: "itemscope",
                global: true,
                deprecated: false,
                nonStandard: false,
                standard:true,
experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /[\s\S]+/g
                    },
                    exceptions: []
                }
            },{
                name: "itemtype",
                global: true,
                deprecated: false,
                nonStandard: false,
                standard:true,
experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /[\s\S]+/g
                    },
                    exceptions: []
                }
            },{
                name: "lang",
                global: true,
                deprecated: false,
                nonStandard: false,
                standard:true,
experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /^(?<language>[a-z]{2})(?:-(?<script>[a-zA-Z]{4}))?(?:-(?<region>[A-Z]{2}|[0-9]{3}))?$/g
                    },
                    exceptions: []
                }
            },{
                name: "nonce",
                global: true,
                deprecated: false,
                nonStandard: false,
                standard:true,
experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /[\s\S]+/g
                    },
                    exceptions: []
                }
            },{
                name: "part",
                global: true,
                deprecated: false,
                nonStandard: false,
                standard:true,
experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /[\s\S]+/g
                    },
                    exceptions: []
                }
            },{
                name: "popover",
                global: true,
                deprecated: false,
                nonStandard: false,
                standard:true,
experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /[\s\S]+/g
                    },
                    exceptions: []
                }
            },{
                name: "slot",
                global: true,
                deprecated: false,
                nonStandard: false,
                standard:true,
experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /[\s\S]+/g
                    },
                    exceptions: []
                }
            },{
                name: "spellcheck",
                global: true,
                deprecated: false,
                nonStandard: false,
                standard:true,
experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /[\s\S]+/g
                    },
                    exceptions: []
                }
            },{
                name: "style",
                global: true,
                deprecated: false,
                nonStandard: false,
                standard:true,
experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /[\s\S]+/g
                    },
                    exceptions: []
                }
            },{
                name: "tabindex",
                global: true,
                deprecated: false,
                nonStandard: false,
                standard:true,
experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /[\s\S]+/g
                    },
                    exceptions: []
                }
            },{
                name: "title",
                global: true,
                deprecated: false,
                nonStandard: false,
                standard:true,
experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /[\s\S]+/g
                    },
                    exceptions: []
                }
            },{
                name: "translate",
                global: true,
                deprecated: false,
                nonStandard: false,
                standard:true,
experimental: false,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /[\s\S]+/g
                    },
                    exceptions: []
                }
            },{
                name: "virtualkeyboardpolicy",
                global: true,
                deprecated: false,
                nonStandard: false,
                experimental: true,
                validation: {
                    default: { 
                        requiredAttributes: [],
                        mutuallyExclusiveAttributes: [],
                        re: /[\s\S]+/g
                    },
                    exceptions: []
                }
            },
        ]

      
        const HTMLElements = [
            {
                name: "input",
                status: "standard",
                startTag: "required",
                endTag: "forbidden",
                categories: ["flow-content", "phrasing-content"],
                content: {
                    ordered: [
                        ["element:p", "element:h1|element:h2|element:h3|element:h4|element:h5|element:h6"],
                        ["element:h1|element:h2|element:h3|element:h4|element:h5|element:h6", "element:p"],
                    ],
                    unordered: ["element:script", "element:template"],
                    forbidden: ["hgroup"]
                },
                attributes: {
                    global: true,
                    standard: ["accept?requires=type"],
                    nonStandard: [],
                    experimental: [],
                    deprecated: [],
                }
            },{
                name: "hgroup",
                status: "standard",
                startTag: "required",
                endTag: "required",
                categories: ["flow-content", "phrasing-content"],
                content: {
                    ordered: [
                        ["element:p", "element:h1|element:h2|element:h3|element:h4|element:h5|element:h6"],
                        ["element:h1|element:h2|element:h3|element:h4|element:h5|element:h6", "element:p"],
                    ],
                    unordered: ["element:script", "element:template"],
                    forbidden: ["hgroup"]
                },
                attributes: {
                    global: true,
                    standard: ["accept"],
                    nonStandard: [],
                    experimental: [],
                    deprecated: [],
                }
            },{
                name: "p",
                status: "standard",
                startTag: "required",
                endTag: "optional?next-sibling=(element:address||element:article||element:aside||element:blockquote||element:details||element:div||element:dl||element:fieldset||element:figcaption||element:figure||element:footer||element:form||element:h1||element:h2||element:h3||element:h4||element:h5||element:h6||element:header||element:hgroup||element:hr||element:main||element:menu||element:nav||element:ol||element:p||element:pre||element:search||element:section||element:table||element:ul)||child-nodelist=empty&&parent-sibling!=(element:a||element:audio||element:del||element:ins||element:map||element:noscript||element:video)",
                categories: ["flow-content", "palpable-content"],
                content: {
                    ordered: [],
                    unordered: ["category:phrasing"],
                    forbidden: []
                },
                attributes: {
                    global: true,
                    standard: [],
                    nonStandard: [],
                    experimental: [],
                    deprecated: [],
                }
            },{
                name: "html",
                status: "standard",
                startTag: "optional?first-child!=comment",
                endTag: "optional?first-child!=comment",
                categories: [],
                content: {
                    ordered: ["element:head", "element:body"],
                    unordered: [],
                    forbidden: []
                },
                attributes: {
                    global: true,
                    standard: [],
                    nonStandard: ["leetest"],
                    experimental: [],
                    deprecated: [],
                }
            },{
                name: "body",
                status: "standard",
                startTag: "optional?child-nodelist=empty||first-child!=(whitespace||comment)",
                endTag: "optional?next-sibling!=comment",
                categories: [],
                content: {
                    ordered: [],
                    unordered: ["category:flow-content"],
                    forbidden: []
                },
                attributes: {
                    global: true,
                    standard: ["onafterprint", "onbeforeprint", "onbeforeunload", "onhashchange", "onlanguagechange", "onmessage", "onmessageerror", "onoffline", "ononline", "onpageswap", "onpagehide", "onpagereveal", "onpageshow", "onpopstate", "onrejectionhandled", "onstorage", "onunhandledrejection", "onunload"],
                    nonStandard: [],
                    experimental: [],
                    deprecated: [],
                }
            },{
                name: "head",
                status: "standard",
                startTag: "optional?child-nodelist=empty||first-child=element",
                endTag: "optional?next-sibling!=(comment|whitespace)",
                categories: [],
                content: {
                    ordered: [],
                    unordered: ["element:title?max=1", "element:base?max=1", "category:metadata-content"],
                    forbidden: []
                },
                attributes: {
                    global: true,
                    standard: ["onafterprint", "onbeforeprint", "onbeforeunload", "onhashchange", "onlanguagechange", "onmessage", "onmessageerror", "onoffline", "ononline", "onpageswap", "onpagehide", "onpagereveal", "onpageshow", "onpopstate", "onrejectionhandled", "onstorage", "onunhandledrejection", "onunload"],
                    nonStandard: [],
                    experimental: [],
                    deprecated: [],
                }
            },{
                name: "h1",
                status: "standard",
                startTag: "required",
                endTag: "required",
                categories: ["flow-content", "palpable-content", "heading-content"],
                content: {
                    ordered: [],
                    unordered: ["category:phrasing"],
                    forbidden: []
                },
                attributes: {
                    global: true,
                    standard: [],
                    nonStandard: [],
                    experimental: [],
                    deprecated: [],
                }
            },{
                name: "h2",
                status: "standard",
                startTag: "required",
                endTag: "required",
                categories: ["flow-content", "palpable-content", "heading-content"],
                content: {
                    ordered: [],
                    unordered: ["category:phrasing"],
                    forbidden: []
                },
                attributes: {
                    global: true,
                    standard: [],
                    nonStandard: [],
                    experimental: [],
                    deprecated: [],
                }
            },{
                name: "h3",
                status: "standard",
                startTag: "required",
                endTag: "required",
                categories: ["flow-content", "palpable-content", "heading-content"],
                content: {
                    ordered: [],
                    unordered: ["category:phrasing"],
                    forbidden: []
                },
                attributes: {
                    global: true,
                    standard: [],
                    nonStandard: [],
                    experimental: [],
                    deprecated: [],
                }
            },{
                name: "h4",
                status: "standard",
                startTag: "required",
                endTag: "required",
                categories: ["flow-content", "palpable-content", "heading-content"],
                content: {
                    ordered: [],
                    unordered: ["category:phrasing"],
                    forbidden: []
                },
                attributes: {
                    global: true,
                    standard: [],
                    nonStandard: [],
                    experimental: [],
                    deprecated: [],
                }
            },{
                name: "h5",
                status: "standard",
                startTag: "required",
                endTag: "required",
                categories: ["flow-content", "palpable-content", "heading-content"],
                content: {
                    ordered: [],
                    unordered: ["category:phrasing"],
                    forbidden: []
                },
                attributes: {
                    global: true,
                    standard: [],
                    nonStandard: [],
                    experimental: [],
                    deprecated: [],
                }
            },{
                name: "h6",
                status: "standard",
                startTag: "required",
                endTag: "required",
                categories: ["flow-content", "palpable-content", "heading-content"],
                content: {
                    ordered: [],
                    unordered: ["category:phrasing"],
                    forbidden: []
                },
                attributes: {
                    global: true,
                    standard: [],
                    nonStandard: [],
                    experimental: [],
                    deprecated: [],
                }
            }
        ]

        /*const htmltesthtml = wrapToken(
            opentag,
            ["html-nodename", `html-opening-tag`],
            {
                id: "htmlnodename",
                actions: [
                    {
                        type: "navigateenter",
                        params: {
                            openingTokenType: "html-opening-tag",
                            closingTokenType: "html-closing-tag",
                            closingTokenTextContent: opentag
                        }
                    }
                ]
            },
            [{
                type:["type"],
                name: "autopredict-tagname",
                params: {
                    openingTokenType: "html-opening-tag",
                    closingTokenType: "html-closing-tag",
                    closingTokenTextContent: opentag
                }
            },{
                type:["navigateenter", "navigateleave"],
                name: "highlight-closing-tag",
                params: {
                    openingTokenType: "html-opening-tag",
                    closingTokenType: "html-closing-tag",
                    closingTokenTextContent: opentag
                }
            }]
        ).outerHTML

        const actions2 = [{
            id: "htmlnodename",
            callbacks: {
                onnavigateenter: (event) => {},
                onnavigateleave: (event) => {},
                ontype: (event) => {},
            }
        }]*/

        /*const docClick = (event) => {}
        const docMouseOver = (event) => {}

        document.addEventListener("click", docClick)
        document.addEventListener("mouseover", docMouseOver)


        <span
            data-onclick="docClick"
            data-onclick-params="{data:'here'}"

        const actions3 = {
            "docClick": (data) => {

            }
        }*/

        const eventListeners = {
            highlightBounds: (event, params) => {
                // Look for js-quote on left & right
                const leftElement = event.token.previousElementSibling;
                const rightElement = event.token.nextElementSibling;

                if(leftElement && leftElement.classList && leftElement.classList.contains(params.openBound)){
                    leftElement.classList.add("highlight-value-start")
                }

                if(rightElement && rightElement.classList && rightElement.classList.contains(params.closeBound)){
                    rightElement.classList.add("highlight-value-end")
                }


                event.token.classList.add("highlight-value")
            },
            removeHighlightBounds: (event, params) => {
                // Look for js-quote on left & right
                const leftQuote = event.token.previousElementSibling;
                const rightQuote = event.token.nextElementSibling;

                leftQuote.classList.remove("highlight-value-start")
                event.token.classList.remove("highlight-value")
                rightQuote.classList.remove("highlight-value-end")
            },
            highlightValue: (event, params) => {
                let walkTag = event.token.nextSibling || parentNextSibling(event.token);
                let openingToken = null;
                let closingToken = null;
                let valueNodes = [];
                let nest = 0;

                while(walkTag) {
                    if(openingToken){
                        valueNodes.push(walkTag);
                    }

                    const classList = walkTag.classList;

                    if(classList){

                        if(classList.contains(params.openingTokenType)){

                            if(!openingToken){
                                openingToken = walkTag;
                                valueNodes.push(walkTag);
                            } else {
                                nest ++;
                            }

                        }

                        if(classList.contains(params.closingTokenType)){

                            if(!closingToken){

                                if(nest === 0){
                                    closingToken = walkTag;
                                    break;
                                } else {
                                    nest --;
                                }

                            }

                        }

                    }

                    if(walkTag.nextSibling){
                        walkTag = walkTag.nextElementSibling;
                    } else {
                        const line = getLine(walkTag);

                        if(line.element.nextElementSibling && line.element.nextElementSibling.firstChild){
                            walkTag = line.element.nextElementSibling.firstChild;
                        } else {
                            walkTag = null;
                        }
                    }

                }

                valueNodes.forEach((node, index) => {
                    const className = (index === 0)
                                            ? "highlight-value-start"
                                            : (index === valueNodes.length - 1)
                                                ? "highlight-value-end"
                                                : "highlight-value"
                    
                    node.classList.add(className)
                })

            },
            removeHighlightValue: (event, params) => {
                let walkTag = event.token.nextSibling || parentNextSibling(event.token);
                let openingToken = null;
                let closingToken = null;
                let valueNodes = [];
                let nest = 0;

                while(walkTag) {
                    if(openingToken){
                        valueNodes.push(walkTag);
                    }

                    const classList = walkTag.classList;

                    if(classList){

                        if(classList.contains(params.openingTokenType)){

                            if(!openingToken){
                                openingToken = walkTag;
                                valueNodes.push(walkTag);
                            } else {
                                nest ++;
                            }

                        }

                        if(classList.contains(params.closingTokenType)){

                            if(!closingToken){

                                if(nest === 0){
                                    closingToken = walkTag;
                                    break;
                                } else {
                                    nest --;
                                }

                            }

                        }

                    }

                    if(walkTag.nextSibling){
                        walkTag = walkTag.nextElementSibling;
                    } else {
                        const line = getLine(walkTag);

                        if(line.element.nextElementSibling && line.element.nextElementSibling.firstChild){
                            walkTag = line.element.nextElementSibling.firstChild;
                        } else {
                            walkTag = null;
                        }
                    }

                }

                valueNodes.forEach((node, index) => {
                    const className = (index === 0)
                                            ? "highlight-value-start"
                                            : (index === valueNodes.length - 1)
                                                ? "highlight-value-end"
                                                : "highlight-value"
                    
                    node.classList.remove(className)
                })

            },
            matchTagPairNames: (event, params) => {

                if(event.type === "typedown"){
                    stopObserving()  
                } else {
                    
                    const masterTagname = event.token.textContent;
                    const tagPairId = event.token.dataset.tagPairId;
                    const selector = `[data-tag-pair-position="${params.updatePosition}"][data-tag-pair-id="${tagPairId}"]`;
                    const updateTag = edit.querySelector(selector)
                    if(updateTag){
                        updateTag.textContent = masterTagname;
                        
                    }
                    validateDoc(event.parentLine.line)
                    updatePreview(edit);
                    startObserving()
                }
            },
            suggestHTMLTagNames: (event, params) => {
                predictiveTagName({
                    token: event.token,
                    parentLine: event.token.parentLine,
                    callback: (selectedTagName) => {
                        stopObserving()  
                        const caretPosition = event.parentLine.caretPosition + selectedTagName.length - 1;

                        event.token.textContent = selectedTagName;
                        const tagPairId = event.token.dataset.tagPairId;
                        const selector = `[data-tag-pair-position="end"][data-tag-pair-id="${tagPairId}"]`;
                        const updateTag = edit.querySelector(selector)
                        if(updateTag){
                            updateTag.textContent = selectedTagName;
                            
                        }
                        if(tagPairId){
                        const tagPair = edit.querySelectorAll(`[data-tag-pair-id='${tagPairId}']`)
                        for(element of tagPair) {
                            element.classList.remove("highlight")
                        }
                    }
                        setCaretPosition({line: event.parentLine.line, caretPosition})
                        validateDoc(event.parentLine.line)
                        updatePreview(edit);
                        startObserving();
                        
                    }
                })
            },
            tagPairAddHighlight: (event, params) => {
                const tagPairId = event.token.dataset.tagPairId;

                if(tagPairId){
                    const tagPair = edit.querySelectorAll(`[data-tag-pair-id='${tagPairId}']`)
                    for(element of tagPair) {
                        element.classList.add("highlight")
                    }
                }
            },
            tagPairRemoveHighlight: (event, params) => {
                const tagPairId = event.token.dataset.tagPairId;

                if(tagPairId){
                    const tagPair = edit.querySelectorAll(`[data-tag-pair-id='${tagPairId}']`)
                    for(element of tagPair) {
                        element.classList.remove("highlight")
                    }
                }
            },
            highlightPairStart: (event, params) => {
                const openingToken = findOpeningToken(event.token, params.openingTokenType, params.closingTokenType, params.openingTokenTextContent)

                if(openingToken){
                    event.token.classList.add("highlight")
                    openingToken.classList.add("highlight")
                } else {
                    event.token.classList.add("highlight-error")

                }
            },
            highlightPairEnd: (event, params) => {
                const closingToken = findClosingToken(event.token, params.openingTokenType, params.closingTokenType, params.closingTokenTextContent)

                if(closingToken){
                    event.token.classList.add("highlight")
                    closingToken.classList.add("highlight")
                } else {
                    event.token.classList.add("highlight-error")

                }
            },
            removeHighlightPairStart: (event, params) => {
                const openingToken = findOpeningToken(event.token, params.openingTokenType, params.closingTokenType, params.openingTokenTextContent)

                if(openingToken){
                    event.token.classList.remove("highlight")
                    openingToken.classList.remove("highlight")
                } else {
                    event.token.classList.remove("highlight-error")

                }
            },
            removeHighlightPairEnd: (event, params) => {
                const closingToken = findClosingToken(event.token, params.openingTokenType, params.closingTokenType, params.closingTokenTextContent)

                if(closingToken){
                    event.token.classList.remove("highlight")
                    closingToken.classList.remove("highlight")
                } else {
                    event.token.classList.remove("highlight-error")

                }
            } 
        }

        const actions = [
            {
                id: "pairclose",
                callbacks: {
                    "type": (event) => {
                        console.log("Change opening tag to this value")
                    },
                    "navigateenter": (event) => {
                        const openingToken = findOpeningToken(event.token, event.params.openingTokenType, event.params.closingTokenType, event.params.openingTokenTextContent)

                        if(openingToken){
                            event.token.classList.add("highlight")
                            openingToken.classList.add("highlight")
                        } else {
                            event.token.classList.add("highlight-error")

                        }
                    },
                    "navigateleave": (event) => {
                        const openingToken = findOpeningToken(event.token, event.params.openingTokenType, event.params.closingTokenType, event.params.openingTokenTextContent)

                        if(openingToken){
                            event.token.classList.remove("highlight")
                            openingToken.classList.remove("highlight")
                        } else {
                            event.token.classList.remove("highlight-error")

                        }
                    }
                }
            },{
                id: "pairopen",
                callbacks: {
                    "type": (event) => {
                        console.log("Change closing tag to this value")
                    },
                    "navigateenter": (event) => {
                        const closingToken = findClosingToken(event.token, event.params.openingTokenType, event.params.closingTokenType, event.params.closingTokenTextContent)

                        if(closingToken){
                            event.token.classList.add("highlight")
                            closingToken.classList.add("highlight")
                        } else {
                            event.token.classList.add("highlight-error")

                        }
                    },
                    "navigateleave": (event) => {
                        const closingToken = findClosingToken(event.token, event.params.openingTokenType, event.params.closingTokenType, event.params.closingTokenTextContent)

                        if(closingToken){
                            event.token.classList.remove("highlight")
                            closingToken.classList.remove("highlight")
                        } else {
                            event.token.classList.remove("highlight-error")

                        }
                    }
                }
            }]

        

        const patterns = [
            {
                mimetype: "css",
                name: "multilineComments",
                re: /(?<multilineComments>\/\*[\s\S]*?\*\/)/g,
                replacerFn: ({multilineComments} = {}) => {
                    let html = multilineComments
                                    .split("\n")
                                    .map((line) => wrapToken(line, ["css-multiline-comment"]).outerHTML)
                                    .join("\n")
                    return html
                }
            },{
                mimetype: "css",
                name: "selectors",
                re: /(?<cssSpacer> *)(?<selector>[\w:> ()-]+)(?= {|,)/g,
                replacerFn: ({cssSpacer, selector} = {}) => {
                    let html = wrapToken({textContent: " ".repeat(cssSpacer.length), classes: ["css-spacer"]}).outerHTML;
                    html += wrapToken({textContent: selector, classes: ["css-selector"]}).outerHTML;
                    return html
                }
            },{
                mimetype: "css",
                name: "css_properties",
                re: /(?<cssProperty>[\w-]+)(?= *:)/g,
                replacerFn: ({cssProperty} = {}) => {
                    let html = wrapToken({textContent: cssProperty, classes: ["css-property"]}).outerHTML;
                    return html
                }
            },{
                mimetype: "css",
                name: "css_values",
                re:  /(?<cssValue>[^:]+)(?= *;)/g,
                replacerFn: ({cssValue} = {}) => {
                    let html = wrapToken({textContent: cssValue, classes: ["css-value"]}).outerHTML;
                    return html
                }
            },{
                mimetype: "css",
                name: "css_curly_open",
                re:  /(?<curlyBraceOpen>{)/g,
                replacerFn: ({curlyBraceOpen} = {}) => {
                    let html = wrapToken({
                        textContent: curlyBraceOpen,
                        classes: ["css-curly-open"],
                        eventListeners: [{
                            type: "navigateenter",
                            id: "highlightPairEnd",
                            params: {
                                openingTokenType: "css-curly-open",
                                closingTokenType: "css-curly-close",
                            }
                        },{
                            type: "navigateleave",
                            id: "removeHighlightPairEnd",
                            params: {
                                openingTokenType: "css-curly-open",
                                closingTokenType: "css-curly-close",
                                }
                        }]
                    }).outerHTML;
                    return html
                }
            },{
                mimetype: "css",
                name: "css_curly_close",
                re: /(?<curlyBraceClose>})/g,
                replacerFn: ({curlyBraceClose} = {}) => {
                    let html = wrapToken({
                        textContent: curlyBraceClose,
                        classes: ["css-curly-close"],
                        eventListeners: [{
                            type: "navigateenter",
                            id: "highlightPairStart",
                            params: {
                                openingTokenType: "css-curly-open",
                                closingTokenType: "css-curly-close",
                            }
                        },{
                            type: "navigateleave",
                            id: "removeHighlightPairStart",
                            params: {
                                openingTokenType: "css-curly-open",
                                closingTokenType: "css-curly-close",
                                }
                            }]
                    }).outerHTML;
                    return html
                }
            },{
                mimetype: "css",
                name: "colon",
                re:  /(?<colon>:)/g,
                replacerFn: ({colon} = {}, parser) => {
                    let html = wrapToken({textContent: colon, classes: ["css-colon"]}).outerHTML;

                    return html

                }
            },{
                mimetype: "css",
                name: "semiColon",
                re:  /(?<semiColon>;)/g,
                replacerFn: ({semiColon} = {}, parser) => {
                    let html = wrapToken({textContent: semiColon, classes: ["css-semi-colon"]}).outerHTML;

                    return html

                }
            },{
                mimetype: "js",
                name: "multilineComments",
                re: /(?<multilineComments>\/\*[\s\S]*?\*\/)/g,
                replacerFn: ({multilineComments} = {}) => {
                    let html = multilineComments
                                    .split("\n")
                                    .map((line) => wrapToken({textContent: line, classes: ["js-multiline-comment"]}).outerHTML)
                                    .join("\n")
                    return html
                }
            },{
                mimetype: "js",
                name: "singleLineComment",
                re: /(?<singleLineComment>\/\/.*)/g,
                replacerFn: ({singleLineComment} = {}) => {
                    let html = wrapToken({textContent: singleLineComment, classes: ["js-comment"]}).outerHTML;
                    return html
                }
            },{
                mimetype: "js",
                name: "stringLiteral",
                re: /`(?<stringLiteral>[\s\S]*?)`/g,
                replacerFn: ({stringLiteral} = {}) => {
                    const variableRe = /\${ *(?<variable>[\w.\[\]"']*) *}/g;

                    let html = wrapToken({textContent: "`", classes: ["js-backtick"]}).outerHTML;

                    html += wrapToken({textContent: stringLiteral, classes: ["js-literal-value"]}).outerHTML;
                    html += wrapToken({textContent: "`", classes: ["js-backtick"]}).outerHTML;

                    html = html.replace(variableRe, (match, variable) => {
                        let _html = wrapToken({
                            textContent: "$",
                            classes: ["js-literal-dollar"],
                            eventListeners: [{
                                type: "navigateenter",
                                id: "highlightValue",
                                params: {
                                    openingTokenType: "js-literal-curly-open",
                                    closingTokenType: "js-literal-curly-close",
                                }
                            },{
                                type: "navigateleave",
                                id: "removeHighlightValue",
                                params: {
                                    openingTokenType: "js-literal-curly-open",
                                    closingTokenType: "js-literal-curly-close",
                                }
                            }]
                        }).outerHTML;
                        _html += wrapToken({
                            textContent: "{",
                            classes: ["js-literal-curly-open"],
                            eventListeners: [{
                                type: "navigateenter",
                                id: "highlightPairEnd",
                                params: {
                                    openingTokenType: "js-literal-curly-open",
                                    closingTokenType: "js-literal-curly-close",
                                }
                            },{
                                type: "navigateleave",
                                id: "removeHighlightPairEnd",
                                params: {
                                    openingTokenType: "js-literal-curly-open",
                                    closingTokenType: "js-literal-curly-close",
                                }
                            }]
                        }).outerHTML;
                        _html += wrapToken({textContent: variable, classes: ["js-literal-variable"]}).outerHTML;
                        _html += wrapToken({
                            textContent: "}",
                            classes: ["js-literal-curly-close"],
                            eventListeners: [{
                                type: "navigateenter",
                                id: "highlightPairStart",
                                params: {
                                    openingTokenType: "js-literal-curly-open",
                                    closingTokenType: "js-literal-curly-close",
                                }
                            },{
                                type: "navigateleave",
                                id: "removeHighlightPairStart",
                                params: {
                                    openingTokenType: "js-literal-curly-open",
                                    closingTokenType: "js-literal-curly-close",
                                }
                            }]
                        }).outerHTML;

                        return _html;
                    })


                    return html
                }
            },{
                mimetype: "js",
                name: "string",
                re: /(?<string>((?<=')(?:[^'].*)(?='))|(?<=\")(?:[^\"].*)(?=\"))/g,
                replacerFn: ({string} = {}) => {
                    let html = wrapToken({
                        textContent: string,
                        classes: ["js-string"],
                        eventListeners: [{
                            type: "navigateenter",
                            id: "highlightBounds",
                            params: {
                                openBound: "js-quote",
                                closeBound: "js-quote",
                            }
                        },{
                            type: "navigateleave",
                            id: "removeHighlightBounds",
                            params: {
                                openBound: "js-quote",
                                closeBound: "js-quote",
                            }
                        }]
                    }).outerHTML;
                    return html
                }
            },{
                mimetype: "js",
                name: "jsonProperty",
                re: /(?!")(?<jsonProp>[\w]+(?="* *:))/g,
                replacerFn: ({jsonProp} = {}) => {
                    let html = wrapToken({textContent: jsonProp, classes: ["json-prop"]}).outerHTML;
                    return html
                }
            },{
                mimetype: "js",
                name: "jsProperty",
                re: /(?<jsProperty>#{0,1}[\w]+)(?= *=)/g,
                replacerFn: ({jsProperty} = {}) => {
                    const className = (jsProperty.charAt(0) === "#")
                        ? "js-private-property"
                        : "js-property"

                    let html = wrapToken({textContent: jsProperty, classes: [className]}).outerHTML;
                    return html
                }
            },{
                mimetype: "js",
                name: "methodName",
                re: /(?<methodName>#{0,1}[\w]+ *)(?=\()/g,
                replacerFn: ({methodName} = {}) => {
                    let html = wrapToken({
                        textContent: methodName,
                        classes: ["js-method-name"],
                        eventListeners: [{
                            type: "navigateenter",
                            id: "highlightValue",
                            params: {
                                openingTokenType: "js-bracket-open",
                                closingTokenType: "js-bracket-close",
                            }
                        },{
                            type: "navigateleave",
                            id: "removeHighlightValue",
                            params: {
                                openingTokenType: "js-bracket-open",
                                closingTokenType: "js-bracket-close",
                            }
                        }]
                    }).outerHTML;
                    return html
                }
            },{
                mimetype: "js",
                name: "symbol",
                re: /(?<symbol>=>|[;=:,<+-])/g,
                replacerFn: ({symbol} = {}) => {
                    let html = wrapToken({textContent: symbol, classes: ["js-symbol"]}).outerHTML;
                    return html
                }
            },{
                mimetype: "js",
                name: "openingCurlyBrace",
                re: /(?<openingCurlyBrace>{)/g,
                replacerFn: ({openingCurlyBrace} = {}) => {
                    let html = wrapToken({
                        textContent: "{",
                        classes: ["js-curly-brace-open"], 
                        eventListeners: [{
                            type: "navigateenter",
                            id: "highlightPairEnd",
                            params: {
                                openingTokenType: "js-curly-brace-open",
                                closingTokenType: "js-curly-brace-close",
                            }
                        },{
                            type: "navigateleave",
                            id: "removeHighlightPairEnd",
                            params: {
                                openingTokenType: "js-curly-brace-open",
                                closingTokenType: "js-curly-brace-close",
                            }
                        }]
                    }).outerHTML;
                    return html
                }
            },{
                mimetype: "js",
                name: "closingCurlyBrace",
                re: /(?<closingCurlyBrace>})/g,
                replacerFn: ({closingCurlyBrace} = {}) => {
                    let html = wrapToken({
                        textContent: "}",
                        classes: ["js-curly-brace-close"], 
                        eventListeners: [{
                            type: "navigateenter",
                            id: "highlightPairStart",
                            params: {
                                openingTokenType: "js-curly-brace-open",
                                closingTokenType: "js-curly-brace-close",
                            }
                        },{
                            type: "navigateleave",
                            id: "removeHighlightPairStart",
                            params: {
                                openingTokenType: "js-curly-brace-open",
                                closingTokenType: "js-curly-brace-close",
                            }
                        }]
                    }).outerHTML;
                    return html
                }
            },{
                mimetype: "js",
                name: "openingBracket",
                re: /(?<openingBracket>\()/g,
                replacerFn: ({openingBracket} = {}) => {
                    let html = wrapToken({
                        textContent: "(",
                        classes: ["js-bracket-open"], 
                        eventListeners: [{
                            type: "navigateenter",
                            id: "highlightPairEnd",
                            params: {
                                openingTokenType: "js-bracket-open",
                                closingTokenType: "js-bracket-close",
                            }
                        },{
                            type: "navigateleave",
                            id: "removeHighlightPairEnd",
                            params: {
                                openingTokenType: "js-bracket-open",
                                closingTokenType: "js-bracket-close",
                            }
                        }]
                    }).outerHTML;
                    return html
                }
            },{
                mimetype: "js",
                name: "closingBracket",
                re: /(?<closingBracket>\))/g,
                replacerFn: ({closingBracket} = {}) => {
                    let html = wrapToken({
                        textContent: ")",
                        classes: ["js-bracket-close"], 
                        eventListeners: [{
                            type: "navigateenter",
                            id: "highlightPairStart",
                            params: {
                                openingTokenType: "js-bracket-open",
                                closingTokenType: "js-bracket-close",
                            }
                        },{
                            type: "navigateleave",
                            id: "removeHighlightPairStart",
                            params: {
                                openingTokenType: "js-bracket-open",
                                closingTokenType: "js-bracket-close",
                            }
                        }]
                    }).outerHTML;
                    return html
                }
            },{
                mimetype: "js",
                name: "openingSquareBracket",
                re: /(?<openingSquareBracket>\[)/g,
                replacerFn: ({openingSquareBracket} = {}) => {
                    let html = wrapToken({
                        textContent: "[",
                        classes: ["js-square-bracket-open"], 
                        eventListeners: [{
                            type: "navigateenter",
                            id: "highlightPairEnd",
                            params: {
                                openingTokenType: "js-square-bracket-open",
                                closingTokenType: "js-square-bracket-close",
                            }
                        },{
                            type: "navigateleave",
                            id: "removeHighlightPairEnd",
                            params: {
                                openingTokenType: "js-square-bracket-open",
                                closingTokenType: "js-square-bracket-close",
                            }
                        }]
                    }).outerHTML;
                    return html
                }
            },{
                mimetype: "js",
                name: "closingSquareBracket",
                re: /(?<closingSquareBracket>\])/g,
                replacerFn: ({closingSquareBracket} = {}) => {
                    let html = wrapToken({
                        textContent: "]",
                        classes: ["js-square-bracket-close"], 
                        eventListeners: [{
                            type: "navigateenter",
                            id: "highlightPairStart",
                            params: {
                                openingTokenType: "js-square-bracket-open",
                                closingTokenType: "js-square-bracket-close",
                            }
                        },{
                            type: "navigateleave",
                            id: "removeHighlightPairStart",
                            params: {
                                openingTokenType: "js-square-bracket-open",
                                closingTokenType: "js-square-bracket-close",
                            }
                        }]
                    }).outerHTML;
                    return html
                }
            },{
                mimetype: "js",
                name: "jsQuotes",
                re: /(?<jsQuote>['\"])/g,
                replacerFn: ({jsQuote} = {}) => {
                    let html = wrapToken({
                        textContent: jsQuote,
                        classes: ["js-quote"]
                    }).outerHTML;
                    return html
                }
            },{
                mimetype: "js",
                name: "keyword",
                re: /(?<keyword>\bconst|let|var|static|class\b)/g,
                replacerFn: ({keyword} = {}) => {
                    let html = wrapToken({textContent: keyword, classes: ["js-keyword", `js-keyword-${keyword}`]}).outerHTML;
                    return html
                }
            },{
                mimetype: "js",
                name: "path",
                re: /(?<path>[\w]+\.)/g,
                replacerFn: ({path} = {}) => {
                    let html = wrapToken({textContent: path, classes: ["js-path"]}).outerHTML;
                    return html
                }
            },{
                mimetype: "js",
                name: "jsVariable",
                re: /(?<jsVariable>#{0,1}[\w]+)/g,
                replacerFn: ({jsVariable} = {}) => {
                    const className = (jsVariable.charAt(0) === "#")
                        ? "js-private-variable"
                        : "js-variable"

                    let html = wrapToken({textContent: jsVariable, classes: [className]}).outerHTML;
                    return html
                }
            },{
                mimetype: "html",
                name: "nodename",
                re: /(?<=<)(?<opentag>[\w-]+)|(?<=\/)(?<closetag>[\w-]+)/g,
                replacerFn: ({opentag, closetag} = {}) => {
                    let html = "";
                    if(opentag){
                        html = wrapToken({
                            textContent: opentag,
                            classes: ["html-nodename", `html-opening-tag`],
                            eventListeners: [{
                                type: "typedown",
                                id: "matchTagPairNames",
                                params: {
                                }
                            },{
                                type: "typeup",
                                id: "matchTagPairNames",
                                params: {
                                    updatePosition: "end"
                                }
                            },{
                                type: "typeup",
                                id: "suggestHTMLTagNames",
                                params: {}
                            },{
                                type: "navigateenter",
                                id: "tagPairAddHighlight",
                                params: {
                                }
                            },{
                                type: "navigateleave",
                                id: "tagPairRemoveHighlight",
                                params: {
                                }
                            }]
                        }).outerHTML
                            
                    } else if (closetag){
                        html = wrapToken({
                            textContent: closetag,
                            classes: ["html-nodename", `html-closing-tag`],
                            eventListeners: [{
                                type: "typedown",
                                id: "matchTagPairNames",
                                params: {
                                }
                            },{
                                type: "typeup",
                                id: "matchTagPairNames",
                                params: {
                                    updatePosition: "start"
                                }
                            },{
                                type: "navigateenter",
                                id: "tagPairAddHighlight",
                                params: {
                                }
                            },{
                                type: "navigateleave",
                                id: "tagPairRemoveHighlight",
                                params: {
                                }
                            }]
                        }).outerHTML

                    }
                   
                    return html
                }
            },{
                mimetype: "html",
                name: "attributes",
                re: /(?!<[^<]* )(?<attrName>[\w\-]*)(?<spacer_1> *)=(?<spacer_2> *)(?:(?:(?<quoteType>["'])(?<stringValue>[\/\w.,=* \-]*)\k<quoteType>)|(?<value>[\w\-.]+))/g,
                replacerFn: ({attrName, spacer_1, spacer_2, quoteType, stringValue, value} = {}) => {
                    let html = wrapToken({textContent: attrName, classes: ["html-attr-name"]}).outerHTML;

                    html += wrapToken({textContent: spacer_1, classes: ["html-spacer"]}).outerHTML
                    html += wrapToken({textContent: "=", classes: ["html-equal-sign"]}).outerHTML
                    html += wrapToken({textContent: spacer_2, classes: ["html-spacer"]}).outerHTML

                    if(quoteType){
                        html += wrapToken({
                            textContent: quoteType,
                            classes: ["html-attr-quote-open"],
                            eventListeners: [{
                                type: "navigateenter",
                                id: "highlightPairEnd",
                                params: {
                                    openingTokenType: "html-attr-quote-open",
                                    closingTokenType: "html-attr-quote-close",
                                }
                            },{
                                type: "navigateleave",
                                id: "removeHighlightPairEnd",
                                params: {
                                    openingTokenType: "html-attr-quote-open",
                                    closingTokenType: "html-attr-quote-close",
                                    }
                            }]
                        }).outerHTML
                    }

                    html += wrapToken({
                        textContent: stringValue||value,
                        classes: ["html-attr-value"],
                        eventListeners: [{
                            type: "navigateenter",
                            id: "highlightBounds",
                            params: {
                                openBound: "html-attr-quote-open",
                                closeBound: "html-attr-quote-close",
                            }
                        },{
                            type: "navigateleave",
                            id: "removeHighlightBounds",
                            params: {
                                openBound: "html-attr-quote-open",
                                closeBound: "html-attr-quote-close",
                            }
                        }]
                    }).outerHTML

                    if(quoteType){
                        html += wrapToken({
                            textContent: quoteType,
                            classes: ["html-attr-quote-close"],
                            eventListeners: [{
                                type: "navigateenter",
                                id: "highlightPairStart",
                                params: {
                                    openingTokenType: "html-attr-quote-open",
                                    closingTokenType: "html-attr-quote-close",
                                }
                            },{
                                type: "navigateleave",
                                id: "removeHighlightPairStart",
                                params: {
                                    openingTokenType: "html-attr-quote-open",
                                    closingTokenType: "html-attr-quote-close",
                                    }
                            }]
                        }).outerHTML
                    }
                    return html
                }
            },{
                mimetype: "html",
                name: "brackets",
                re: /(?<selfClosingBracket>\/>)|(?<closeTagLeftBracket><\/)(?=[\w]+>)|(?<openTagLeftBracket><)(?=[\w-]+)|(?!<[\s\S]*?)(?<rightBracket>>)/g,
                replacerFn: ({selfClosingBracket, closeTagLeftBracket, openTagLeftBracket, rightBracket} = {}) => {
                    let html = "";
                    const leftBracketListeners = [{
                        type: "navigateenter",
                        id: "highlightPairEnd",
                        params: {
                            openingTokenType: "html-bracket-left",
                            closingTokenType: "html-bracket-right",
                        }
                    },{
                        type: "navigateleave",
                        id: "removeHighlightPairEnd",
                        params: {
                            openingTokenType: "html-bracket-left",
                            closingTokenType: "html-bracket-right",
                            }
                    }];

                    const rightBracketListeners = [{
                        type: "navigateenter",
                        id: "highlightPairStart",
                        params: {
                            openingTokenType: "html-bracket-left",
                            closingTokenType: "html-bracket-right",
                        }
                    },{
                        type: "navigateleave",
                        id: "removeHighlightPairStart",
                        params: {
                            openingTokenType: "html-bracket-left",
                            closingTokenType: "html-bracket-right",
                            }
                    }];
                    
                    if(openTagLeftBracket){
                        html += wrapToken({
                            textContent: "<",
                            classes: ["html-bracket-left"],
                            eventListeners: leftBracketListeners
                        }).outerHTML
                    } else if(closeTagLeftBracket){
                        html += wrapToken({
                            textContent: "<",
                            classes: ["html-bracket-left"],
                            eventListeners: leftBracketListeners
                        }).outerHTML
                        html += wrapToken({textContent: "/", classes: ["html-back-slash"]}).outerHTML

                    } else if(rightBracket){
                        html += wrapToken({
                            textContent: ">",
                            classes: ["html-bracket-right"],
                            eventListeners: rightBracketListeners
                        }).outerHTML

                    } else if(selfClosingBracket){
                        html += wrapToken({textContent: "/", classes: ["html-back-slash"]}).outerHTML
                        html += wrapToken({
                            textContent: ">",
                            classes: ["html-bracket-right"],
                            eventListeners: rightBracketListeners
                        }).outerHTML

                    }
                    return html
                }
            },{
                mimetype: "all",
                name: "whitespaces",
                re: /(?<lineIndent>^[ ]+)/g,
                replacerFn: ({lineIndent} = {}) => {
                    let classes = ["editor-whitespace", "editor-indent"];
                    let textContent = " ".repeat(lineIndent.length);

                    let html = wrapToken({textContent, classes}).outerHTML

                    return html
                }
            }

        ]

        const cachedPatterns = {}

        const createUUID = ({prefix = "", removeDashes = false} = {}) => {
            let randomUUID = crypto.randomUUID();

            if(removeDashes){
                randomUUID.replace("-", "");
            }

            return `${prefix}${randomUUID}`
        }

        const getPatternsByMimetype = (mimetype) => {
            const replacerFunctions = {};
            let regularExpressions = [];

            patterns
                .filter(pattern => pattern.mimetype === mimetype || pattern.mimetype === "all")
                .forEach((pattern, index) => {
                    const uuid = `__PATTERN__${mimetype.toUpperCase()}_${index}`;
                    const re = `(?<${uuid}>${pattern.re.source})`;

                    replacerFunctions[uuid] = pattern.replacerFn;
                    regularExpressions.push(re);
                })
            
            return cachedPatterns[mimetype] = {
                re: new RegExp(regularExpressions.join("|"), "g"),
                replacerFunctions
            } 
        }

        const splitToLines = (plaintext, mimetype) => {
            return plaintext
                .split("\n")
                .map(line => {
                    if(line.startsWith("{{{")){
                        return line
                    }

                    if(line.trim().length === 0){
                        line = " "
                    }
                    const docFrag = createFragmentFromString(line);
                    const wrapper = document.createElement("li")
                    wrapper.setAttribute("data-mimetype", mimetype)
                    wrapper.classList.add("editor-line")

                    wrapper.append(...docFrag.childNodes)

                    return wrapper.outerHTML
                })
                .join("")
        }

        const mimetypeTagMap = {
            "style": "css",
            "script": "js",
        }

        const parse = (plaintext, mimetype) => {
            const blocksRe = /(?<=<(?<blocktype>script|style)[\w\-=" ]*>)(?<content>[\w\W]*?)(?=<\/\k<blocktype>>)/g;
            const blocks = [];

            plaintext = plaintext.replace(blocksRe, (match, blockType, content) => {
                const uuid = crypto.randomUUID();
                let placeholder = `\n{{{${uuid}}}}\n`
                blocks.push({
                    uuid,
                    blockType,
                    content
                })

                return placeholder
            })
            
            const {re, replacerFunctions} = cachedPatterns[mimetype] || getPatternsByMimetype(mimetype);

            plaintext = plaintext.replace(re, (match, ...args) => {
                const groups = args[args.length - 1];
                const groupsAsArray = Array.from(Object.entries(groups));

                const [uuid] = groupsAsArray.find(([group, value]) => group.startsWith(`__PATTERN__${mimetype.toUpperCase()}_`) && value);

                const html = replacerFunctions[uuid](groups)

                return html
            })


            let parsedLines = splitToLines(plaintext, mimetype);
            
            // Cant do a replace on doc. Need to search for the placeholder in the array of lines
            blocks.forEach((block) => {
                const mimetype = mimetypeTagMap[block.blockType];

                const {re, replacerFunctions} = cachedPatterns[mimetype] || getPatternsByMimetype(mimetype);

                if(Object.keys(replacerFunctions).length > 0){
                    
                    const blockDoc = block.content.replace(re, (match, ...args) => {
                        const groups = args[args.length - 1];
                        const groupsAsArray = Array.from(Object.entries(groups));

                        const [uuid] = groupsAsArray.find(([group, value]) => group.startsWith(`__PATTERN__${mimetype.toUpperCase()}_`) && value);

                        const html = replacerFunctions[uuid](groups)

                        return html
                    })

                    const lines = splitToLines(blockDoc, mimetype)

                    parsedLines = parsedLines.replace(`{{{${block.uuid}}}}`, lines)
                }

                
            })

           

            return parsedLines

        }

        
        const selection = window.getSelection();

        let parsed = parse(truth.value, "html")

        edit.innerHTML = parsed;
        validateDoc()

        const updatePreview = (node) => {
            const plaintext = node.textContent;
            // Convert Edit text content into doc fragment and put in iframe
            const domParser = new DOMParser();
            const doc = domParser.parseFromString(plaintext, "text/html")

            const scripts = doc.querySelectorAll("script");

            const newScripts = Array.from(scripts).map(script => {
                const scriptElement = document.createElement("script")
                const scriptText = document.createTextNode(`
                    (function() {
                    try {
                        ${script.textContent}
                    } catch(error) {
                        console.error('Error in user code:', error);
                    }
                })();`)

                scriptElement.append(scriptText);
                script.remove()

                return scriptElement;
            })

            
            preview.contentWindow.document.firstChild.replaceWith(doc.firstChild);



            // Add event listeners to preview
            const previewBody = preview.contentWindow.document.querySelector("body");
            previewBody.append(...newScripts)

            
            
        }


        updatePreview(edit)

        const getLine = (node) => {
            const line = (node.classList && node.classList.contains("editor-line"))
                    ? node
                    : node.parentNode.closest(".editor-line");

            const mimetype = line.getAttribute("data-mimetype")
            const plaintext = line.textContent;
            
            return {
                line,
                mimetype,
                plaintext,
                element: line
            }
        }

       

        const getCaret = () => {
            const target = selection.anchorNode;
            const caretPosition = selection.anchorOffset;
            const parentLine = getLine(target)

            const treeWalk = document.createTreeWalker(parentLine.element, NodeFilter.SHOW_TEXT);

            parentLine.caretPosition = caretPosition;

            while(treeWalk.nextNode()) {
                if(treeWalk.currentNode === target){
                    // Found the node, stop counting
                    break;
                }

                parentLine.caretPosition += treeWalk.currentNode.textContent.length
            }

            const previousChar = parentLine.plaintext.charAt(parentLine.caretPosition - 1);
            const nextChar = parentLine.plaintext.charAt(parentLine.caretPosition);

            const token = getToken(target);

            const nextCharToken = getTokenAt(parentLine.element, parentLine.caretPosition + 1)

            const actions = (token && token.dataset && token.dataset.actions)
                                ? JSON.parse(token.dataset.actions)
                                : null
            
            const eventListeners = (token && token.dataset && token.dataset.eventListeners)
                                ? JSON.parse(token.dataset.eventListeners)
                                : null

            
            const siblingToken = (nextCharToken)
                ? {
                    target: nextCharToken,
                    caretPosition: caretPosition + 1,
                    parentLine,
                    previousChar: nextChar,
                    nextChar: parentLine.plaintext.charAt(parentLine.caretPosition + 1),
                    token: nextCharToken,
                    siblingToken: null,
                    eventListeners: (nextCharToken.dataset && nextCharToken.dataset.eventListeners) ? JSON.parse(nextCharToken.dataset.eventListeners) : null,
                    actions: (nextCharToken.dataset && nextCharToken.dataset.actions) ? JSON.parse(nextCharToken.dataset.actions) : null
                }
                : null;

            return {
                target,
                caretPosition,
                parentLine,
                previousChar,
                nextChar,
                token,
                siblingToken,
                eventListeners,
                actions,
            }
        }

        


        /* SUCCEEDED BY getCaret() */
        const getCaretPosition = () => {
            const anchorNode = selection.anchorNode;
            const anchorOffset = selection.anchorOffset;
            const {line, mimetype} = getLine(anchorNode);
            let caretPosition = anchorOffset;
            const treeWalk = document.createTreeWalker(line, NodeFilter.SHOW_TEXT);
            const plaintext = line.textContent;

            while(treeWalk.nextNode()) {
                if(treeWalk.currentNode === anchorNode){
                    // Found the node, stop counting
                    break;
                }

                caretPosition += treeWalk.currentNode.textContent.length
            }

            const character = {
                prev: plaintext.charAt(caretPosition - 1),
                next: plaintext.charAt(caretPosition),
            }

            
            const token = {
                prevChar: (caretPosition > 0) ? getTokenAt(line, caretPosition) : null,
                nextChar: getTokenAt(line, caretPosition + 1),
                anchorNode: getToken(anchorNode)
            }

            return {
                anchorNode,
                anchorOffset,
                caretPosition,
                line,
                mimetype,
                character,
                token
            }
        }

        const setCaretPosition = ({line, caretPosition} = {}) => {
            const treeWalk = document.createTreeWalker(line, NodeFilter.SHOW_TEXT);
            let counter = 0;
            let targetNode = null;

            while(treeWalk.nextNode()) {
                if(counter + treeWalk.currentNode.textContent.length >= caretPosition){
                    targetNode = treeWalk.currentNode;
                    caretPosition = caretPosition - counter
                    break;
                }

                counter += treeWalk.currentNode.textContent.length
            }

            if(targetNode === null){
                targetNode = line.nextSibling.firstChild
                caretPosition = 0
            }

            if(targetNode){
                selection.setPosition(targetNode, caretPosition)

            }
        }

        const updateEditor = (node) => {
            let {caretPosition, anchorNode, anchorOffset} = getCaretPosition();
            const {line} = getLine(node)

            const mimetype = line.getAttribute("data-mimetype")

            const plaintext = line.textContent;
            const parsedText = parse(plaintext, mimetype);
            const docFrag = createFragmentFromString(parsedText);
            const newLineStart = docFrag.firstChild

            line.replaceWith(...docFrag.childNodes)



            setCaretPosition({line: newLineStart, caretPosition});

        }

        let history = [];
        let redo = [];


        const observer = new MutationObserver((records, observer) => {
            if(records.length === 1 && records[0].addedNodes.length > 0){
                //console.log("SYSTEM UPDATE")

            } else {
                //console.log("USER UPDATES")
                const uniqueRecords = records.filter((record, index, self) => record.target.isConnected)
                const firstRecord = uniqueRecords[0].target;

                updateEditor(firstRecord);
                updatePreview(edit);
                validateDoc();

                // Add hsitory stuff to its own function or link to updateEditor()
                /*const lines = Array.from(edit.querySelectorAll("li"));
                const historyEntry = lines
                                        .map(line => line.textContent)
                                        .join("\n");

                history.push(historyEntry)
                redo = []*/

                
            }

            
        });

        const startObserving = () => {
            const observerConfig = { childList: true, subtree: true, characterData: true, characterDataOldValue: true, attributes: false };
            observer.observe(edit, observerConfig);
        }

        const stopObserving = () => {
            observer.disconnect();
        }

        startObserving();

        
        

    </script>

</body>
</html>